[{"name":"GJumper","comment":" The GJumper console is a template for a grid based game.\nIt has the following Properties:\n\n  - It displayes a 16x16 screen around the player. The player is always positioned\n    at (7,7) within the scren.\n  - It provides a 1x16 tiles high header and a 3x16 tiles high footer.\n  - It uses the Buttons WASD (or arrow keys) for movement and ESC to reset the game.\n  - Pressing a WASD button will first move the player and THEN trigger the tick-function.\n\n\n# Main Type\n\n@docs GameData, Status\n\n\n# Defining a Game\n\n@docs define, InitModel, View, view\n\n\n# Additional Features\n\n@docs withGui, footer, header, Footer, Header, Game\n\n","unions":[{"name":"Status","comment":" At any point in time a game is either ongoing, Won or Lost. Once the game is\ndone, the game can be reset by pressing a buttion, some of the data can be also\ntransfered from one game session to another (like a level counter).\n","args":[],"cases":[["Ongoing",[]],["Won",[]],["Lost",[]]]}],"aliases":[{"name":"Footer","comment":" a Footer\n","args":[],"type":"GJumper.Core.Footer"},{"name":"Game","comment":" The type of a game.\n","args":["square","model"],"type":"PixelEngine.PixelEngine () (GJumper.Model square model) GJumper.Msg"},{"name":"GameData","comment":" The `Model` of a GJumper Game contains a player position, a grid and some\naditional data.\n\nyou can define a `square` how ever you want. Any information, that can not be\nstored in the grid should be part of the `data`.\n\n","args":["square","data"],"type":"{ data : data, grid : Grid.Grid square, player : Grid.Position.Position }"},{"name":"Header","comment":" a header\n","args":[],"type":"GJumper.Core.Header"},{"name":"InitModel","comment":" The initial model.\n\n  - data : some custom data (anything you like)\n  - player : The starting position of the player on the grid\n  - rows : the height of the grid\n  - columns : the width of the grid\n  - level : a Matrix (list of lists) of squares. If an entry is Nothing, it might\n    be filled later with additional stuff.\n  - fixed : after the level has be created a fixed amount of squares will be\n    randomly placed within all empty squares.\n  - distribution: next all empty sqaures get filled regarding the given distribution.\n    The Float stated the relative occurence of the given spare. If some spots should\n    stay empty, you need to add `(float,Nothing)` to the list where `float` is higher then 0.\n\n","args":["square","data"],"type":"{ data : data, player : Grid.Position.Position, distribution : data -> ( ( Basics.Float, Maybe.Maybe square ), List.List ( Basics.Float, Maybe.Maybe square ) ), fixed : data -> List.List ( Basics.Int, square ), level : data -> List.List (List.List (Maybe.Maybe square)), rows : Basics.Int, columns : Basics.Int }"},{"name":"View","comment":" The view of the model\n","args":["square"],"type":"GJumper.Core.View square"}],"values":[{"name":"define","comment":" the main function of the game console.\n\n  - init : the intial model (dependent on randomnes). It maybe inputs data\n    from a previous run (like a level counter).\n  - isSolid : specifies whether a square is solid\n  - tick : updates the game (dependent on randomnes) and also returns the current\n    status of the game. This function will only be called if the player could\n    successfully move (if the square is not solid)\n  - view : specifies the gui.\n  - title : The title of the game\n  - imgSize : the size of a square, tile.\n  - gameWon : a end screen after the game has been won. The screen is\n    imgSize\\*16 x imgSize\\*20 big.\n  - gameOver : a end screen after the game has been lost. The screen is\n    imgSize\\*16 x imgSize\\*20 big.\n\n","type":"{ init : Maybe.Maybe data -> Random.Generator (GJumper.InitModel square data), isSolid : square -> Basics.Bool, tick : GJumper.GameData square data -> Random.Generator ( GJumper.GameData square data, GJumper.Status ), view : data -> GJumper.View square, title : String.String, imgSize : Basics.Int, gameWon : List.List ( ( Basics.Float, Basics.Float ), PixelEngine.Image.Image Basics.Never ), gameOver : List.List ( ( Basics.Float, Basics.Float ), PixelEngine.Image.Image Basics.Never ) } -> GJumper.Game square data"},{"name":"footer","comment":" a footer. the floats specify the x position. It must be between 0 and 16\\*imgSize.\nThe y position depends on the list (first list has y=0, second list has y=1 and third has y = 2)\n","type":"List.List ( Basics.Float, PixelEngine.Image.Image Basics.Never ) -> List.List ( Basics.Float, PixelEngine.Image.Image Basics.Never ) -> List.List ( Basics.Float, PixelEngine.Image.Image Basics.Never ) -> GJumper.Footer"},{"name":"header","comment":" a header, the floats specify the x position. It must be between 0 and 16\\*imgSize.\n","type":"List.List ( Basics.Float, PixelEngine.Image.Image Basics.Never ) -> GJumper.Header"},{"name":"view","comment":" specifies how things look.\n\nIt uses the [Tile](https://package.elm-lang.org/packages/Orasund/pixelengine/latest/PixelEngine-Tile) from Orasund/pixelengine.\n\n","type":"{ player : PixelEngine.Tile.Tile Basics.Never, square : square -> PixelEngine.Tile.Tile Basics.Never } -> PixelEngine.Tile.Tileset -> PixelEngine.Background -> GJumper.View square"},{"name":"withGui","comment":" adds a Gui to the view.\n","type":"GJumper.Header -> GJumper.Footer -> PixelEngine.Background -> GJumper.View square -> GJumper.View square"}],"binops":[]},{"name":"Grid","comment":" A `Grid` is a dictionary that has a size constraint.\r\nHere is an example where such a grid is used:\r\n[Snake Example](https://orasund.github.io/pixelengine/#Snake).\r\n\r\n\r\n# Grids\r\n\r\n@docs Grid\r\n\r\n\r\n# Build\r\n\r\n@docs fill, empty, insert, update, remove\r\n\r\n\r\n# Query\r\n\r\n@docs isEmpty, member, get, size, dimensions\r\n\r\n\r\n# List\r\n\r\n@docs positions, emptyPositions, values, toList, fromList\r\n\r\n\r\n# Dict\r\n\r\n@docs toDict, fromDict\r\n\r\n\r\n# Transform\r\n\r\n@docs map, foldl, foldr, filter, partition, find\r\n\r\n\r\n# Combine\r\n\r\n@docs union, intersect, diff\r\n\r\n","unions":[{"name":"Grid","comment":" A grid with a fixes amount of columns and rows.\r\n\r\nIt will wrap the borders (apply ModBy), making every position valid.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> get ( -1, 0 )\r\n    --> grid |> get ( (dimensions |> .columns) - 1, 0 )\r\n\r\nIf instead you want to have hard border around your grid, use `Grid.Bordered` instead.\r\n\r\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a value when its position does not appear in the second grid.\r\n","type":"Grid.Grid a -> Grid.Grid a -> Grid.Grid a"},{"name":"dimensions","comment":" Return the dimensions of the grid.\r\n\r\n    dim : { columns:Int , rows:Int }\r\n    dim =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dim\r\n\r\n    grid |> dimensions\r\n    --> dim\r\n\r\n","type":"Grid.Grid a -> { columns : Basics.Int, rows : Basics.Int }"},{"name":"empty","comment":" Create an empty grid\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    empty dimensions\r\n    --> fill (always Nothing ) dimensions\r\n\r\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Grid.Grid a"},{"name":"emptyPositions","comment":" Get all empty positions in a grid, sorted from lowest to highest.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid Int\r\n    grid =\r\n        fill\r\n            (always <| Just <| 42)\r\n            dimensions\r\n\r\n    grid |> remove (2,2) |> emptyPositions\r\n    --> [(2,2)]\r\n\r\n","type":"Grid.Grid a -> List.List Grid.Position.Position"},{"name":"fill","comment":" Create a grid\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    fill (always <| Just ()) dimensions |> emptyPositions\r\n    --> []\r\n\r\n","type":"(Grid.Position.Position -> Maybe.Maybe a) -> { rows : Basics.Int, columns : Basics.Int } -> Grid.Grid a"},{"name":"filter","comment":" Keep only the values that pass the given test.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid Int\r\n    grid =\r\n        empty dimensions\r\n            |> insert (2,4) 2\r\n            |> insert (2,3) 42\r\n\r\n    grid |> filter (\\_ -> (==) 42) |> values\r\n    --> [42]\r\n\r\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Grid a -> Grid.Grid a"},{"name":"find","comment":" Find the first value that passes a given test.\r\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Grid a -> Maybe.Maybe ( Grid.Position.Position, a )"},{"name":"foldl","comment":" Fold over **all** positions in a grid, row by row, from top down.\r\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Grid v -> b"},{"name":"foldr","comment":" Fold over **all** positions in a grid, row by row, from bottum up.\r\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Grid v -> b"},{"name":"fromDict","comment":" Convert an dictionary to a grid\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid Int\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> toDict |> fromDict dimensions |> get (2,2)\r\n    --> Nothing\r\n\r\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Dict.Dict Grid.Position.Position a -> Grid.Grid a"},{"name":"fromList","comment":" Convert an association list into a grid.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid Int\r\n    grid =\r\n        empty dimensions\r\n\r\n    [((2,2),42),((2,1),20)] |> fromList dimensions\r\n    --> grid |> insert (2,2) 42 |> insert (2,1) 20\r\n\r\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> List.List ( Grid.Position.Position, a ) -> Grid.Grid a"},{"name":"get","comment":" Get the value associated with a position. If the position is empty, return Nothing.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> get (2,2)\r\n    --> Just 42\r\n\r\n","type":"Grid.Position.Position -> Grid.Grid a -> Maybe.Maybe a"},{"name":"insert","comment":" Insert a value at a position in a grid. Replaces value when there is a collision.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> get (2,2)\r\n    --> Just 42\r\n\r\n","type":"Grid.Position.Position -> a -> Grid.Grid a -> Grid.Grid a"},{"name":"intersect","comment":" Keep a value when its position appears in the second grid.\r\nPreference is given to values in the first grid.\r\n","type":"Grid.Grid a -> Grid.Grid a -> Grid.Grid a"},{"name":"isEmpty","comment":" Determine if a grid is empty.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> isEmpty --> True\r\n    grid |> insert (2,2) 42 |> isEmpty --> False\r\n\r\n","type":"Grid.Grid a -> Basics.Bool"},{"name":"map","comment":" Apply a function to **all** positions in a grid.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    empty dimensions |> map (\\_ _ -> Just 42)\r\n    --> fill (always <| Just 42) dimensions\r\n\r\n","type":"(Grid.Position.Position -> Maybe.Maybe a -> Maybe.Maybe b) -> Grid.Grid a -> Grid.Grid b"},{"name":"member","comment":" Determine if a position is empty.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> member (2,2)\r\n    --> True\r\n\r\n","type":"Grid.Position.Position -> Grid.Grid a -> Basics.Bool"},{"name":"partition","comment":" Partition a grid according to some test.\r\n\r\nThe first grid contains all values which passed the test,\r\nand the second contains the values that did not.\r\n\r\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Grid a -> ( Grid.Grid a, Grid.Grid a )"},{"name":"positions","comment":" Get all non empty positions in a grid, sorted from lowest to highest.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> positions\r\n    --> [(2,2)]\r\n\r\n","type":"Grid.Grid a -> List.List Grid.Position.Position"},{"name":"remove","comment":" Remove a vlaue from a grid. If the position is empty, no changes are made.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> get (2,2) --> Just 42\r\n    grid |> insert (2,2) 42 |> remove (2,2) |> get (2,2)\r\n    --> Nothing\r\n\r\n","type":"Grid.Position.Position -> Grid.Grid a -> Grid.Grid a"},{"name":"size","comment":" Determine the number of values in the grid.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> size\r\n    --> 1\r\n\r\n","type":"Grid.Grid a -> Basics.Int"},{"name":"toDict","comment":" Convert a grid into an associated dictionary\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid Int\r\n    grid =\r\n        empty dimensions\r\n            |> insert (2,2) 42\r\n\r\n    grid |> toDict |> fromDict dimensions |> get (2,2)\r\n    --> Just 42\r\n\r\n","type":"Grid.Grid a -> Dict.Dict Grid.Position.Position a"},{"name":"toList","comment":" Convert a grid into an association list of position-value pairs,\r\nsorted by the position.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid Int\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> toList\r\n    --> [( (2,2), 42 )]\r\n\r\n","type":"Grid.Grid a -> List.List ( Grid.Position.Position, a )"},{"name":"union","comment":" Combine two grids.\r\nIf there is a collision, preference is given to the first grid.\r\n","type":"Grid.Grid a -> Grid.Grid a -> Grid.Grid a"},{"name":"update","comment":" Update the value of a grid for a specific position with a given function.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> update (2,2) (always <| Just 42)\r\n    --> grid |> insert (2,2) 42\r\n\r\n","type":"Grid.Position.Position -> (Maybe.Maybe a -> Maybe.Maybe a) -> Grid.Grid a -> Grid.Grid a"},{"name":"values","comment":" Get all of the values in a grid, in the order of their positions.\r\n\r\n    dimensions : { columns:Int , rows:Int }\r\n    dimensions =\r\n        { columns=42\r\n        , rows=3\r\n        }\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty dimensions\r\n\r\n    grid |> insert (2,2) 42 |> values\r\n    --> [42]\r\n\r\n","type":"Grid.Grid a -> List.List a"}],"binops":[]},{"name":"Grid.Bordered","comment":" A grid with a hard border around the edges. you cant read or write from squares\r\noutside the border.\r\nHere is an example where such a grid is used:\r\n[Space Invaders](https://orasund.github.io/pixelengine/#SpaceInvaders).\r\n\r\n\r\n# Error\r\n\r\n@docs Error, ignoringErrors\r\n\r\n\r\n# Grids\r\n\r\n@docs Grid\r\n\r\n\r\n# Build\r\n\r\n@docs fill, empty, insert, update, remove\r\n\r\n\r\n# Query\r\n\r\n@docs isEmpty, member, get, isValid, size, dimensions\r\n\r\n\r\n# List\r\n\r\n@docs positions, emptyPositions, values, toList, fromList\r\n\r\n\r\n# Dict\r\n\r\n@docs toDict, fromDict\r\n\r\n\r\n# Transform\r\n\r\n@docs map, foldl, foldr, filter, partition, find\r\n\r\n\r\n# Combine\r\n\r\n@docs union, intersect, diff\r\n\r\n","unions":[{"name":"Error","comment":" Possible Errors.\r\n\r\n  - `OutOfBounds` - the position is not valid\r\n  - `NotSuccessful` - the function as a problem fulfilling the task. (Maybe the position is occupied?)\r\n\r\n","args":[],"cases":[["OutOfBounds",[]],["NotSuccessful",[]]]},{"name":"Grid","comment":" A grid of values.\r\n\r\nIt has a fixed amount of columns and rows.\r\n\r\nIf case of a invalid position, it returns an error.\r\n\r\n    grid |> Grid.insert ( -1, 0 ) virus == Err OutOfBounds\r\n\r\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Keep a value when its position does not appear in the second grid.\r\n","type":"Grid.Bordered.Grid a -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"dimensions","comment":" return the dimensions of the grid\r\n","type":"Grid.Bordered.Grid a -> { columns : Basics.Int, rows : Basics.Int }"},{"name":"empty","comment":" Create an empty grid\r\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Grid.Bordered.Grid a"},{"name":"emptyPositions","comment":" Get all empty positions in a grid, sorted from lowest to highest.\r\n","type":"Grid.Bordered.Grid a -> List.List Grid.Position.Position"},{"name":"fill","comment":" Create a grid\r\n","type":"(Grid.Position.Position -> Maybe.Maybe a) -> { rows : Basics.Int, columns : Basics.Int } -> Grid.Bordered.Grid a"},{"name":"filter","comment":" Keep only the values that pass the given test.\r\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"find","comment":" Find the first value that passes a given test.\r\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Bordered.Grid a -> Maybe.Maybe ( Grid.Position.Position, a )"},{"name":"foldl","comment":" Fold over **all** positions in a grid, row by row, from top down.\r\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Bordered.Grid v -> b"},{"name":"foldr","comment":" Fold over **all** positions in a grid, row by row, from bottum up.\r\n","type":"(Grid.Position.Position -> Maybe.Maybe v -> b -> b) -> b -> Grid.Bordered.Grid v -> b"},{"name":"fromDict","comment":" Convert an dictionary to a grid\r\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> Dict.Dict Grid.Position.Position a -> Grid.Bordered.Grid a"},{"name":"fromList","comment":" Convert an association list into a grid.\r\n","type":"{ rows : Basics.Int, columns : Basics.Int } -> List.List ( Grid.Position.Position, a ) -> Grid.Bordered.Grid a"},{"name":"get","comment":" Get the value associated with a position. If the position is empty, return Nothing.\r\nReturns an `OutOfBounds` Error if the position is invalid.\r\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Maybe.Maybe a)"},{"name":"ignoringErrors","comment":" Trys modifying a grid and if its fails it returns the original grid.\r\n\r\nPlease be aware, that by using this function you might introduce errors.\r\n\r\n","type":"(Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)) -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"insert","comment":" Insert a value at a position in a grid. Returns a `NotSuccessful` error if\r\nthe position is occupied.\r\n","type":"Grid.Position.Position -> a -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)"},{"name":"intersect","comment":" Keep a value when its position appears in the second grid.\r\nPreference is given to values in the first grid.\r\n","type":"Grid.Bordered.Grid a -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"isEmpty","comment":" Determine if a grid is empty.\r\n","type":"Grid.Bordered.Grid a -> Basics.Bool"},{"name":"isValid","comment":" checks if a position is valid.\r\n\r\n    grid : Grid a\r\n    grid =\r\n        empty\r\n            { columns=42\r\n            , rows=3\r\n            }\r\n\r\n\r\n    grid |> isValid (-1,0) --> False\r\n    grid |> isValid (41,0) --> True\r\n    grid |> isValid (42,0) --> False\r\n\r\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Basics.Bool"},{"name":"map","comment":" Apply a function to **all** positions in a grid.\r\n","type":"(Grid.Position.Position -> Maybe.Maybe a -> Maybe.Maybe b) -> Grid.Bordered.Grid a -> Grid.Bordered.Grid b"},{"name":"member","comment":" Determine if a position is empty.\r\nReturns an `OutOfBounds` Error if the position is invalid.\r\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error Basics.Bool"},{"name":"partition","comment":" Partition a grid according to some test.\r\n\r\nThe first grid contains all values which passed the test,\r\nand the second contains the values that did not.\r\n\r\n","type":"(Grid.Position.Position -> a -> Basics.Bool) -> Grid.Bordered.Grid a -> ( Grid.Bordered.Grid a, Grid.Bordered.Grid a )"},{"name":"positions","comment":" Get all non empty positions in a grid, sorted from lowest to highest.\r\n","type":"Grid.Bordered.Grid a -> List.List Grid.Position.Position"},{"name":"remove","comment":" Remove a vlaue from a grid. If the position is empty, it returs a\r\n`NotSuccessful` error.\r\n","type":"Grid.Position.Position -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)"},{"name":"size","comment":" Determine the number of values in the grid.\r\n","type":"Grid.Bordered.Grid a -> Basics.Int"},{"name":"toDict","comment":" Convert a grid into an associated dictionary\r\n","type":"Grid.Bordered.Grid a -> Dict.Dict Grid.Position.Position a"},{"name":"toList","comment":" Convert a grid into an association list of position-value pairs, sorted by the position.\r\n","type":"Grid.Bordered.Grid a -> List.List ( Grid.Position.Position, a )"},{"name":"union","comment":" Combine two grids.\r\nIf there is a collision, preference is given to the first grid.\r\n","type":"Grid.Bordered.Grid a -> Grid.Bordered.Grid a -> Grid.Bordered.Grid a"},{"name":"update","comment":" Update the value of a grid for a specific position with a given function.\r\n","type":"Grid.Position.Position -> (Maybe.Maybe a -> Result.Result () (Maybe.Maybe a)) -> Grid.Bordered.Grid a -> Result.Result Grid.Bordered.Error (Grid.Bordered.Grid a)"},{"name":"values","comment":" Get all of the values in a grid, in the order of their keys.\r\n","type":"Grid.Bordered.Grid a -> List.List a"}],"binops":[]},{"name":"Grid.Direction","comment":"\r\n\r\n@docs Direction, flip, rotLeft, rotRight\r\n\r\n","unions":[{"name":"Direction","comment":" A abstract concept of a direction on a grid.\r\n","args":[],"cases":[["Up",[]],["Down",[]],["Left",[]],["Right",[]]]}],"aliases":[],"values":[{"name":"flip","comment":" Rotates a `Direction` for 180 Degrees.\r\n\r\n```\r\nUp\r\n|> flip\r\n--> Down\r\n```\r\n\r\n```\r\nLeft\r\n|> flip\r\n--> Right\r\n```\r\n","type":"Grid.Direction.Direction -> Grid.Direction.Direction"},{"name":"rotLeft","comment":" Rotates a `Direction` clockwise\r\n\r\n```\r\nUp\r\n|> rotLeft\r\n|> Left\r\n```\r\n","type":"Grid.Direction.Direction -> Grid.Direction.Direction"},{"name":"rotRight","comment":" Rotates a `Direction` counter-clockwise\r\n\r\n```\r\nUp\r\n|> rotRight\r\n|> Right\r\n```\r\n","type":"Grid.Direction.Direction -> Grid.Direction.Direction"}],"binops":[]},{"name":"Grid.Position","comment":" This module contains two ways of representing a point on a grid:\r\n`Position` and `Coord`. Positions are meant to be stored, and coordinates are\r\nmeant to to calculations with.\r\n\r\n\r\n# Position\r\n\r\n@docs Position, move, add, coordsTo\r\n\r\n\r\n# Vector\r\n\r\n@docs Coord, fromDirection, toDirection, distance, scaleBy, length\r\n\r\n","unions":[],"aliases":[{"name":"Coord","comment":" `Coord` is a non-comparable representation for 2D Coordinates.\r\n\r\nUse this type for your calculations.\r\n\r\n","args":[],"type":"{ x : Basics.Int, y : Basics.Int }"},{"name":"Position","comment":" A `Position` is a comparable representation for 2D Coordinates.\r\n\r\nYou should store your coordinates in this type.\r\n\r\n","args":[],"type":"( Basics.Int, Basics.Int )"}],"values":[{"name":"add","comment":" Apply Coordinates to a position to get the relative position.\r\n\r\n```\r\nmove amount direction == add ( fromDirection direction |> scaleby amount)\r\n```\r\n\r\n","type":"Grid.Position.Coord -> Grid.Position.Position -> Grid.Position.Position"},{"name":"coordsTo","comment":" Returns the difference between two positions.\r\n\r\n```\r\ndifference p1 p2 == p1 <------- p2\r\n```\r\n\r\n","type":"Grid.Position.Position -> Grid.Position.Position -> Grid.Position.Coord"},{"name":"distance","comment":" Gets the distance between to points.\r\n(The length of the difference)\r\n\r\n```\r\ndistance == vectorTo >> length\r\n```\r\n\r\n","type":"Grid.Position.Position -> Grid.Position.Position -> Basics.Float"},{"name":"fromDirection","comment":" converts a `Direction` into a `Vector` with length `1`.\r\n","type":"Grid.Direction.Direction -> Grid.Position.Coord"},{"name":"length","comment":" Returns the length of the coordinate (distance to (0,0)\r\n","type":"Grid.Position.Coord -> Basics.Float"},{"name":"move","comment":" moves a Point some amount of steps in a direction. This is the most used\r\nway how to change a position.\r\n","type":"Basics.Int -> Grid.Direction.Direction -> Grid.Position.Position -> Grid.Position.Position"},{"name":"scaleBy","comment":" Scales Coordnates. Coordnates obtained by `fromDirection` have size 1.\r\n\r\n```\r\nfromDirection angle |> scaleBy l |> length == l\r\n```\r\n\r\n","type":"Basics.Int -> Grid.Position.Coord -> Grid.Position.Coord"},{"name":"toDirection","comment":" converts **any** `Vector` into its nearest `Direction` value.\r\n\r\nfromValue (0,0) == Right\r\nfromValue (1,1) == Down\r\nfromValue (-1,1) == Down\r\nfromValue (1,-1) == Up\r\nfromValue (-1,-1) == Up\r\n\r\n","type":"Grid.Position.Coord -> Grid.Direction.Direction"}],"binops":[]},{"name":"Location","comment":" This module contains two different type for repesenting a 2D Point:\r\n`Location` and `Vector`. The idea is to use `Locations` to store a Point and `Vector`\r\nto do caluclations. This way the compiler knows exactly what you are doing and can\r\ngive you appropriate error messages.\r\n\r\n\r\n# Angle\r\n\r\n@docs Angle, toAngle\r\n\r\n\r\n# Location\r\n\r\n@docs Location, move, add, vectorTo\r\n\r\n\r\n# Vector\r\n\r\n@docs Vector, fromAngle, distance, rotate, scaleBy, length\r\n\r\n","unions":[{"name":"Angle","comment":" A Angle should store Elm angles (radians).\r\n\r\nUse the functions `degrees`,`radias`,`turns` or `pi` to obtain a Angle.\r\n\r\n```\r\nAngle <| degree 90\r\n```\r\n\r\n","args":[],"cases":[["Angle",["Basics.Float"]]]}],"aliases":[{"name":"Location","comment":" A `Location` a point, possibly stored in a dictionary. Thats why its a tuple.\r\nBut doing calulations with tuples can get very chaotic, thats why the module provides\r\n`Vectors`.\r\n","args":[],"type":"( Basics.Float, Basics.Float )"},{"name":"Vector","comment":" A Vector is used for calculations.\r\n","args":[],"type":"{ x : Basics.Float, y : Basics.Float }"}],"values":[{"name":"add","comment":" simple adds a vector to a location, from geometry we know that a vector is\r\nactually just an angle and a length.\r\n\r\n```\r\nadd ( fromAngle angle |> scaleby length)\r\n--> move length angle\r\n```\r\n\r\n","type":"Location.Vector -> Location.Location -> Location.Location"},{"name":"distance","comment":" The `Distance` between two locations is the length of the resulting vector\r\n\r\n```\r\ndistance == vectorTo >> length\r\n```\r\n\r\n","type":"Location.Location -> Location.Location -> Basics.Float"},{"name":"fromAngle","comment":" construct a unit vector from an angle\r\n\r\n```\r\nfromAngle (Angle (pi/4) )\r\n|> length\r\n--> 1\r\n```\r\n\r\n","type":"Location.Angle -> Location.Vector"},{"name":"length","comment":" Returns the length of the coordinate (distance to (0,0)\r\n","type":"Location.Vector -> Basics.Float"},{"name":"move","comment":" given a `Location`, a distance in some direction. This is the most used\r\nway how to change a location.\r\n```\r\n(0,0) |> move 1 (Angle 0)\r\n--> (1,0)\r\n```\r\n","type":"Basics.Float -> Location.Angle -> Location.Location -> Location.Location"},{"name":"rotate","comment":" rotate a Vector\r\n\r\n```\r\n{ x = 1, y = 0 } |> rotate (Angle (pi/2))\r\n--> {x = 0, y = -1}\r\n```\r\n\r\n","type":"Location.Angle -> Location.Vector -> Location.Vector"},{"name":"scaleBy","comment":" Scales a Vector. Vectors obtained by `fromAngle` have size 1.\r\n\r\n```\r\nfromAngle (Angle (pi/4) ) |> scaleBy 42 |> length\r\n--> 42\r\n```\r\n\r\n","type":"Basics.Float -> Location.Vector -> Location.Vector"},{"name":"toAngle","comment":" An Angle can be constructed from a Vector.\r\n\r\n```\r\n{x=0,y=0} |> Location.toAngle\r\n--> 0\r\n```\r\n\r\n","type":"Location.Vector -> Location.Angle"},{"name":"vectorTo","comment":" The difference between to locations is a vector.\r\n\r\n```\r\nloc1 <----- loc2\r\n```\r\n\r\nthe resulting vector points from the second value to the first.\r\n\r\n```\r\n(1,0) |> vectorTo (1,1)\r\n--> { x = 0, y = 1 }\r\n```\r\n\r\n","type":"Location.Location -> Location.Location -> Location.Vector"}],"binops":[]}]